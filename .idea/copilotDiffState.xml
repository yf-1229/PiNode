<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/pinode/ui/home/HomeScreen.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/pinode/ui/home/HomeScreen.kt" />
              <option name="originalContent" value="package com.pinode.ui.home&#10;&#10;import androidx.activity.compose.BackHandler&#10;import androidx.compose.animation.core.animateFloatAsState&#10;import androidx.compose.foundation.BorderStroke&#10;import androidx.compose.foundation.background&#10;import androidx.compose.foundation.clickable&#10;import androidx.compose.foundation.interaction.MutableInteractionSource&#10;import androidx.compose.foundation.layout.Arrangement&#10;import androidx.compose.foundation.layout.Box&#10;import androidx.compose.foundation.layout.Column&#10;import androidx.compose.foundation.layout.PaddingValues&#10;import androidx.compose.foundation.layout.Row&#10;import androidx.compose.foundation.layout.Spacer&#10;import androidx.compose.foundation.layout.WindowInsets&#10;import androidx.compose.foundation.layout.asPaddingValues&#10;import androidx.compose.foundation.layout.calculateEndPadding&#10;import androidx.compose.foundation.layout.fillMaxSize&#10;import androidx.compose.foundation.layout.fillMaxWidth&#10;import androidx.compose.foundation.layout.height&#10;import androidx.compose.foundation.layout.padding&#10;import androidx.compose.foundation.layout.safeDrawing&#10;import androidx.compose.foundation.layout.size&#10;import androidx.compose.foundation.layout.wrapContentSize&#10;import androidx.compose.foundation.lazy.LazyColumn&#10;import androidx.compose.foundation.lazy.items&#10;import androidx.compose.foundation.lazy.rememberLazyListState&#10;import androidx.compose.foundation.shape.CircleShape&#10;import androidx.compose.foundation.shape.RoundedCornerShape&#10;import androidx.compose.material.icons.Icons&#10;import androidx.compose.material.icons.filled.Add&#10;import androidx.compose.material.icons.filled.ArrowUpward&#10;import androidx.compose.material.icons.filled.Bolt&#10;import androidx.compose.material.icons.filled.CalendarMonth&#10;import androidx.compose.material.icons.filled.Check&#10;import androidx.compose.material.icons.filled.Close&#10;import androidx.compose.material.icons.filled.KeyboardArrowDown&#10;import androidx.compose.material.icons.filled.Pause&#10;import androidx.compose.material.icons.outlined.ArrowUpward&#10;import androidx.compose.material.icons.outlined.Bolt&#10;import androidx.compose.material.icons.outlined.CalendarMonth&#10;import androidx.compose.material.icons.outlined.Pause&#10;import androidx.compose.material3.AlertDialog&#10;import androidx.compose.material3.ButtonGroupDefaults&#10;import androidx.compose.material3.CardDefaults&#10;import androidx.compose.material3.DropdownMenu&#10;import androidx.compose.material3.DropdownMenuItem&#10;import androidx.compose.material3.ExperimentalMaterial3Api&#10;import androidx.compose.material3.ExperimentalMaterial3ExpressiveApi&#10;import androidx.compose.material3.FloatingActionButtonMenu&#10;import androidx.compose.material3.FloatingActionButtonMenuItem&#10;import androidx.compose.material3.Icon&#10;import androidx.compose.material3.MaterialTheme&#10;import androidx.compose.material3.MaterialTheme.colorScheme&#10;import androidx.compose.material3.OutlinedCard&#10;import androidx.compose.material3.Scaffold&#10;import androidx.compose.material3.SplitButtonDefaults&#10;import androidx.compose.material3.SplitButtonLayout&#10;import androidx.compose.material3.Text&#10;import androidx.compose.material3.TextButton&#10;import androidx.compose.material3.ToggleButton&#10;import androidx.compose.material3.ToggleFloatingActionButton&#10;import androidx.compose.material3.ToggleFloatingActionButtonDefaults.animateIcon&#10;import androidx.compose.material3.TopAppBarDefaults&#10;import androidx.compose.material3.animateFloatingActionButton&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.runtime.LaunchedEffect&#10;import androidx.compose.runtime.collectAsState&#10;import androidx.compose.runtime.derivedStateOf&#10;import androidx.compose.runtime.getValue&#10;import androidx.compose.runtime.mutableIntStateOf&#10;import androidx.compose.runtime.mutableStateOf&#10;import androidx.compose.runtime.remember&#10;import androidx.compose.runtime.rememberCoroutineScope&#10;import androidx.compose.runtime.saveable.rememberSaveable&#10;import androidx.compose.runtime.setValue&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.draw.clip&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.graphics.graphicsLayer&#10;import androidx.compose.ui.graphics.vector.rememberVectorPainter&#10;import androidx.compose.ui.input.nestedscroll.nestedScroll&#10;import androidx.compose.ui.platform.LocalLayoutDirection&#10;import androidx.compose.ui.res.colorResource&#10;import androidx.compose.ui.res.dimensionResource&#10;import androidx.compose.ui.res.stringResource&#10;import androidx.compose.ui.semantics.CustomAccessibilityAction&#10;import androidx.compose.ui.semantics.Role&#10;import androidx.compose.ui.semantics.contentDescription&#10;import androidx.compose.ui.semantics.customActions&#10;import androidx.compose.ui.semantics.isTraversalGroup&#10;import androidx.compose.ui.semantics.role&#10;import androidx.compose.ui.semantics.semantics&#10;import androidx.compose.ui.semantics.stateDescription&#10;import androidx.compose.ui.semantics.traversalIndex&#10;import androidx.compose.ui.text.TextStyle&#10;import androidx.compose.ui.text.style.LineBreak&#10;import androidx.compose.ui.text.style.TextAlign&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.unit.sp&#10;import androidx.compose.ui.window.Dialog&#10;import androidx.lifecycle.viewmodel.compose.viewModel&#10;import androidx.navigation.NavController&#10;import com.pinode.BottomNavigationBar&#10;import com.pinode.PiNodeTopAppBar&#10;import com.pinode.R&#10;import com.pinode.data.Node&#10;import com.pinode.data.NodeStatus&#10;import com.pinode.ui.AppViewModelProvider&#10;import com.pinode.ui.item.DateTimeCtrl&#10;import com.pinode.ui.navigation.NavigationDestination&#10;import kotlinx.coroutines.delay&#10;import kotlinx.coroutines.launch&#10;import java.time.Duration&#10;import java.time.LocalDateTime&#10;import java.time.format.DateTimeFormatter&#10;&#10;&#10;object HomeDestination : NavigationDestination {&#10;    override val route = &quot;home&quot;&#10;    override val titleRes = R.string.today_title&#10;}&#10;&#10;@OptIn(ExperimentalMaterial3Api::class, ExperimentalMaterial3ExpressiveApi::class)&#10;@ExperimentalMaterial3Api&#10;@Composable&#10;fun HomeScreen(&#10;    navigateToNodeAddFast: () -&gt; Unit,&#10;    navigateToNodeAdd: (Boolean) -&gt; Unit,&#10;    navigateToNodeEdit: (Int) -&gt; Unit, // ← ここで編集画面への遷移関数を受け取る&#10;    navController: NavController,&#10;    viewModel: HomeViewModel = viewModel(factory = AppViewModelProvider.Factory),&#10;    modifier: Modifier = Modifier,&#10;) {&#10;    val homeUiState by viewModel.homeUiState.collectAsState()&#10;&#10;    val scrollBehavior = TopAppBarDefaults.enterAlwaysScrollBehavior()&#10;    val coroutineScope = rememberCoroutineScope()&#10;&#10;    Scaffold(&#10;        modifier = modifier.nestedScroll(scrollBehavior.nestedScrollConnection),&#10;        topBar = {&#10;            PiNodeTopAppBar(&#10;                canNavigateBack = false,&#10;                scrollBehavior = scrollBehavior&#10;            )&#10;        },&#10;        floatingActionButton = {&#10;            val listState = rememberLazyListState()&#10;            val items = listOf(&#10;                Icons.Default.Bolt to &quot;Fast Add&quot;,&#10;                Icons.Default.Add to &quot;Add&quot;&#10;            )&#10;            val fabVisible by remember { derivedStateOf { listState.firstVisibleItemIndex == 0 } }&#10;            var fabMenuExpanded by rememberSaveable { mutableStateOf(false) }&#10;            BackHandler(fabMenuExpanded) { fabMenuExpanded = false }&#10;            FloatingActionButtonMenu(&#10;                expanded = fabMenuExpanded,&#10;                button = {&#10;                    ToggleFloatingActionButton(&#10;                        modifier = Modifier&#10;                            .semantics {&#10;                                traversalIndex = -1f&#10;                                stateDescription = if (fabMenuExpanded) &quot;Expanded&quot; else &quot;Collapsed&quot;&#10;                                contentDescription = &quot;Toggle menu&quot;&#10;                            }&#10;                            .animateFloatingActionButton(&#10;                                visible = fabVisible || fabMenuExpanded,&#10;                                alignment = Alignment.BottomEnd&#10;                            ),&#10;                        checked = fabMenuExpanded,&#10;                        onCheckedChange = { fabMenuExpanded = !fabMenuExpanded }&#10;                    ) {&#10;                        val imageVector by remember {&#10;                            derivedStateOf {&#10;                                if (checkedProgress &gt; 0.5f) Icons.Filled.Close else Icons.Filled.Add&#10;                            }&#10;                        }&#10;                        Icon(&#10;                            painter = rememberVectorPainter(imageVector),&#10;                            contentDescription = null,&#10;                            modifier = Modifier.animateIcon({ checkedProgress })&#10;                        )&#10;                    }&#10;                },&#10;            ) {&#10;                items.forEachIndexed { i, item -&gt;&#10;                    FloatingActionButtonMenuItem(&#10;                        onClick = {&#10;                            if (i == 0) {&#10;                                navigateToNodeAddFast()&#10;                            } else if (i == 1) {&#10;                                navigateToNodeAdd(true)&#10;                            }&#10;                        },&#10;                        containerColor = colorScheme.primary,&#10;                        icon = { Icon(item.first, contentDescription = null) },&#10;                        text = { Text(text = item.second) },&#10;                        modifier = Modifier&#10;                            .padding(&#10;                                end = WindowInsets.safeDrawing&#10;                                    .asPaddingValues()&#10;                                    .calculateEndPadding(LocalLayoutDirection.current)&#10;                            )&#10;                            .semantics {&#10;                                isTraversalGroup = true&#10;                                if (i == items.size - 1) {&#10;                                    customActions =&#10;                                        listOf(&#10;                                            CustomAccessibilityAction(&#10;                                                label = &quot;Close menu&quot;,&#10;                                                action = {&#10;                                                    fabMenuExpanded = false&#10;                                                    true&#10;                                                }&#10;                                            )&#10;                                        )&#10;                                }&#10;                            }&#10;                        )&#10;                }&#10;            }&#10;        },&#10;        bottomBar = {&#10;            BottomNavigationBar(navController = navController)&#10;        }&#10;    ) { innerPadding -&gt;&#10;        HomeBody(&#10;            nodeList = homeUiState.nodeList.filter { !it.isCompleted &amp;&amp; it.status != NodeStatus.NOTTODO },&#10;            completeItem = { nodeId -&gt;&#10;                coroutineScope.launch {&#10;                    viewModel.updateNodeId(nodeId)&#10;                }&#10;                viewModel.completeNode(nodeId)&#10;            },&#10;            editStatus = { nodeId -&gt;&#10;                navigateToNodeEdit(nodeId)&#10;            },&#10;            selectedStatus = { nodeId, status -&gt;&#10;                coroutineScope.launch {&#10;                    viewModel.updateNodeId(nodeId)&#10;                }&#10;                viewModel.changeNodeStatus(nodeId, status)&#10;            },&#10;            modifier = modifier.fillMaxSize(),&#10;            contentPadding = innerPadding&#10;        )&#10;    }&#10;}&#10;&#10;@Composable&#10;fun HomeBody(&#10;    nodeList: List&lt;Node&gt;,&#10;    completeItem: (Int) -&gt; Unit,&#10;    editStatus: (Int) -&gt; Unit,&#10;    selectedStatus: (Int, NodeStatus) -&gt; Unit,&#10;    modifier: Modifier = Modifier,&#10;    contentPadding: PaddingValues = PaddingValues(0.dp)&#10;) {&#10;    Column(&#10;        horizontalAlignment = Alignment.Start,&#10;        modifier = modifier,&#10;    ) {&#10;        if (nodeList.isEmpty()) {&#10;            Text(&#10;                text = stringResource(R.string.no_node_description),&#10;                textAlign = TextAlign.Center,&#10;                style = MaterialTheme.typography.titleLarge,&#10;                modifier = Modifier.padding(contentPadding),&#10;            )&#10;        } else {&#10;            Box {&#10;                PiNodeList(&#10;                    nodeList = nodeList,&#10;                    completeItem = { node -&gt; completeItem(node.id)},&#10;                    editStatus = { node -&gt; editStatus(node.id) },&#10;                    selectedStatus = { node, status -&gt; selectedStatus(node.id, status)},&#10;                    contentPadding = contentPadding,&#10;                    modifier = Modifier.padding(horizontal = dimensionResource(id = R.dimen.padding_small))&#10;                )&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;&#10;@Composable&#10;private fun PiNodeList(&#10;    nodeList: List&lt;Node&gt;,&#10;    completeItem: (Node) -&gt; Unit,&#10;    editStatus: (Node) -&gt; Unit,&#10;    selectedStatus: (Node, NodeStatus) -&gt; Unit,&#10;    contentPadding: PaddingValues,&#10;    modifier: Modifier = Modifier&#10;) {&#10;    Box {&#10;        var showDialog by remember { mutableStateOf(false) }&#10;        var selectedNode by remember { mutableStateOf&lt;Node?&gt;(null) }&#10;&#10;        LazyColumn(&#10;            modifier = modifier,&#10;            contentPadding = contentPadding&#10;        ) {&#10;            if (nodeList.isNotEmpty()) {&#10;                items(&#10;                    items = nodeList,&#10;                    key = { node -&gt; node.id }  // keyを明示的に設定&#10;                ) { item -&gt;&#10;                    PiNodeItem(&#10;                        item = item,&#10;                        onItemTap = { node -&gt;&#10;                            selectedNode = node&#10;                            showDialog = true&#10;                        },&#10;                        completeItem = { node -&gt; completeItem(node)},&#10;                        editStatus = { node -&gt; editStatus(node) },&#10;                        showDialog = showDialog&#10;                    )&#10;                }&#10;            }&#10;        }&#10;&#10;        // null safety&#10;        if (showDialog &amp;&amp; selectedNode != null) {&#10;            NodeDetailDialog(&#10;                onDismissRequest = {&#10;                    showDialog = false&#10;                    selectedNode = null&#10;                },&#10;                item = selectedNode!!, // null safety&#10;                selectedStatus = { node, status -&gt; selectedStatus(node, status) },&#10;                editStatus = {&#10;                    node -&gt; editStatus(node)&#10;                    showDialog = false&#10;                }&#10;            )&#10;        }&#10;    }&#10;}&#10;&#10;&#10;@Composable&#10;fun PiNodeItem(&#10;    item: Node,&#10;    onItemTap: (Node) -&gt; Unit,&#10;    completeItem: (Node) -&gt; Unit,&#10;    editStatus: (Node) -&gt; Unit,&#10;    showDialog: Boolean,&#10;    modifier: Modifier = Modifier&#10;) {&#10;    // 状態を使用して現在時刻を保持し、更新可能にする&#10;    var currentTime by remember { mutableStateOf(DateTimeCtrl().getNow()) }&#10;&#10;    // 一定間隔で時間を更新&#10;    LaunchedEffect(key1 = Unit) {&#10;        while(true) {&#10;            delay(100)&#10;            currentTime = DateTimeCtrl().getNow()&#10;        }&#10;    }&#10;&#10;    val deadline = item.deadline&#10;    val duration = deadline?.let { dateTime -&gt;&#10;        try {&#10;            Duration.between(LocalDateTime.now(), dateTime)&#10;        } catch (e: Exception) {&#10;            Duration.ZERO&#10;        }&#10;    } ?: Duration.ZERO&#10;&#10;    val remainingTime = if (deadline == null) {&#10;        &quot;&quot; // 期限なし&#10;    } else if (deadline &gt; LocalDateTime.now() &amp;&amp; duration &lt;= Duration.ofHours(1)){&#10;        // last 1 hour&#10;        duration.toMinutes()&#10;    } else if (duration == Duration.ZERO) {&#10;        // out of deadline&#10;        &quot;0&quot;&#10;    } else if (deadline &lt; LocalDateTime.now()) {&#10;        // out of deadline&#10;        val formatter = DateTimeFormatter.ofPattern(&quot;yyyy M/d H:mm&quot;)&#10;        &quot;-${formatter.format(item.deadline)}-&quot;&#10;    } else if (deadline.year &gt; LocalDateTime.now().year) {&#10;        // others year&#10;        val formatter = DateTimeFormatter.ofPattern(&quot;yyyy M/d H:mm&quot;)&#10;        formatter.format(item.deadline)&#10;    } else if (deadline.month == LocalDateTime.now().month &amp;&amp; deadline.dayOfMonth == LocalDateTime.now().dayOfMonth) {&#10;        // today&#10;        val formatter = DateTimeFormatter.ofPattern(&quot;H:mm&quot;)&#10;        formatter.format(item.deadline)&#10;    } else {&#10;        // this year&#10;        val formatter = DateTimeFormatter.ofPattern(&quot;M/d H:mm&quot;)&#10;        formatter.format(item.deadline)&#10;    }&#10;&#10;    OutlinedCard(&#10;        colors = CardDefaults.cardColors(&#10;            containerColor = colorScheme.surface,&#10;        ),&#10;        border = BorderStroke(1.dp, Color.White),&#10;        modifier = Modifier&#10;            .padding(bottom = 6.dp)&#10;            .fillMaxWidth()&#10;            .clickable(&#10;                indication = null,&#10;                interactionSource = remember { MutableInteractionSource() }&#10;            ) {&#10;                onItemTap(item)&#10;            }&#10;    ) {&#10;        Column(modifier = Modifier&#10;            .fillMaxWidth()&#10;            .padding(6.dp)&#10;        ) {&#10;            // ここでRowを使って左右に分ける&#10;            Row(&#10;                verticalAlignment = Alignment.CenterVertically,&#10;                horizontalArrangement = Arrangement.SpaceBetween,&#10;                modifier = Modifier.fillMaxWidth()&#10;            ) {&#10;                // ステータスインジケーター&#10;                Box(&#10;                    modifier = Modifier&#10;                        .padding(start = 6.dp, top = 6.dp)&#10;                        .size(20.dp)&#10;                        .clip(CircleShape)&#10;                        .background(&#10;                            if (item.status != null) {&#10;                                colorResource(item.status.color)&#10;                            } else {&#10;                                Color.Black&#10;                            }&#10;                        )&#10;                )&#10;                // SplitButton&#10;                Box(&#10;                    modifier = Modifier&#10;                        .wrapContentSize()&#10;                        .height(40.dp)&#10;                ) {&#10;                    if(!showDialog) {&#10;                        SplitButton(item = item, completeItem = completeItem, editStatus = editStatus) }&#10;                }&#10;            }&#10;            Text( // deadline&#10;                text = remainingTime.toString(),&#10;                color = Color.Gray,&#10;                fontSize = 16.sp,&#10;            )&#10;&#10;            Text( // title&#10;                text = item.title,&#10;                color = Color.White,&#10;                fontSize = 32.sp,&#10;                modifier = Modifier.padding(start = 8.dp),&#10;                style = TextStyle.Default.copy(&#10;                    lineBreak = LineBreak.Heading&#10;                )&#10;            )&#10;                // TODO Sub Todo List&#10;        }&#10;    }&#10;}&#10;&#10;@OptIn(ExperimentalMaterial3ExpressiveApi::class)&#10;@Composable&#10;private fun SplitButton(&#10;    item: Node, completeItem: (Node) -&gt; Unit, editStatus: (Node) -&gt; Unit&#10;) {&#10;    var checked by remember { mutableStateOf(false) }&#10;    SplitButtonLayout(&#10;        modifier = Modifier.height(40.dp),&#10;        leadingButton = {&#10;            SplitButtonDefaults.LeadingButton(&#10;                onClick = {&#10;                    // 同期的に状態を更新&#10;                    completeItem(item)&#10;                },&#10;                modifier = Modifier.height(40.dp)&#10;            ) {&#10;                Icon(&#10;                    Icons.Filled.Check,&#10;                    modifier = Modifier.size(16.dp),&#10;                    contentDescription = &quot;Localized description&quot;,&#10;                )&#10;                Spacer(Modifier.size(4.dp))&#10;                Text(&quot;Complete&quot;, fontSize = 12.sp)&#10;            }&#10;        },&#10;        trailingButton = {&#10;            SplitButtonDefaults.TrailingButton(&#10;                checked = checked,&#10;                onCheckedChange = {&#10;                    checked = it&#10;                },&#10;                modifier = Modifier&#10;                    .height(40.dp)&#10;                    .semantics {&#10;                        stateDescription =&#10;                            if (checked) &quot;Expanded&quot; else &quot;Collapsed&quot;&#10;                        contentDescription = &quot;Toggle Button&quot;&#10;                    },&#10;            ) {&#10;                val rotation: Float by animateFloatAsState(&#10;                    targetValue = if (checked) 180f else 0f,&#10;                    label = &quot;Trailing Icon Rotation&quot;,&#10;                )&#10;                Icon(&#10;                    Icons.Filled.KeyboardArrowDown,&#10;                    modifier = Modifier&#10;                        .size(16.dp)&#10;                        .graphicsLayer {&#10;                            this.rotationZ = rotation&#10;                        },&#10;                    contentDescription = &quot;Localized description&quot;,&#10;                )&#10;            }&#10;        },&#10;    )&#10;    DropdownMenu(&#10;        expanded = checked,&#10;        onDismissRequest = { checked = false },&#10;        modifier = Modifier.clip(RoundedCornerShape(6.dp))&#10;    ) {&#10;        DropdownMenuItem(&#10;            text = { Text(&quot;Edit&quot;)},&#10;            onClick = {&#10;                editStatus(item)&#10;                checked = false // メニューを閉じる&#10;            },&#10;        )&#10;    }&#10;}&#10;&#10;@OptIn(ExperimentalMaterial3ExpressiveApi::class)&#10;@Composable&#10;private fun NodeDetailDialog(&#10;    onDismissRequest: () -&gt; Unit,&#10;    item : Node,&#10;    selectedStatus: (Node, NodeStatus) -&gt; Unit,&#10;    editStatus: (Node) -&gt; Unit,&#10;) {&#10;    Dialog(&#10;        onDismissRequest = onDismissRequest,&#10;    ) {&#10;        Column {&#10;            PiNodeItem(&#10;                item = item,&#10;                onItemTap = { node -&gt; editStatus(node) },&#10;                completeItem = {},&#10;                editStatus = {},&#10;                showDialog = true,&#10;            )&#10;            Spacer(modifier = Modifier.height(8.dp))&#10;            DetailsButtonGroup(item, selectedStatus)&#10;        }&#10;    }&#10;}&#10;&#10;&#10;@Composable&#10;@ExperimentalMaterial3ExpressiveApi&#10;private fun DetailsButtonGroup(item: Node, selectedStatus: (Node, NodeStatus) -&gt; Unit) {&#10;    val options = listOf(&#10;        NodeStatus.WORKING, NodeStatus.PAUSE, NodeStatus.CARRYOVER, NodeStatus.FAST&#10;    )&#10;    val unCheckedIcons =&#10;        listOf(Icons.Outlined.ArrowUpward, Icons.Outlined.Pause, Icons.Outlined.CalendarMonth, Icons.Outlined.Bolt)&#10;    val checkedIcons =&#10;        listOf(Icons.Default.ArrowUpward, Icons.Default.Pause, Icons.Default.CalendarMonth, Icons.Default.Bolt)&#10;    var selectedIndex by remember { mutableIntStateOf(0) }&#10;&#10;    Row(&#10;        Modifier.padding(horizontal = 8.dp),&#10;        horizontalArrangement = Arrangement.spacedBy(ButtonGroupDefaults.ConnectedSpaceBetween),&#10;    ) {&#10;        options.forEachIndexed { index, label -&gt;&#10;            ToggleButton(&#10;                checked = selectedIndex == index,&#10;                onCheckedChange = {&#10;                    selectedIndex = index&#10;                    selectedStatus(item, options[index])&#10;                    },&#10;                modifier = Modifier&#10;                    .weight(1f)&#10;                    .semantics { role = Role.RadioButton },&#10;                shapes =&#10;                when (index) {&#10;                    0 -&gt; ButtonGroupDefaults.connectedLeadingButtonShapes()&#10;                    options.lastIndex -&gt; ButtonGroupDefaults.connectedTrailingButtonShapes()&#10;                    else -&gt; ButtonGroupDefaults.connectedMiddleButtonShapes()&#10;                },&#10;            ) {&#10;                Icon(&#10;                    if (selectedIndex == index) checkedIcons[index] else unCheckedIcons[index],&#10;                    contentDescription = &quot;Localized description&quot;,&#10;                )&#10;            }&#10;        }&#10;    }&#10;} // TODO add edit and delete button&#10;&#10;@Composable&#10;private fun DeleteConfirmationDialog(&#10;    onDeleteConfirm: () -&gt; Unit, onDeleteCancel: () -&gt; Unit, modifier: Modifier = Modifier&#10;) {&#10;    AlertDialog(onDismissRequest = { /* Do nothing */ },&#10;        title = { Text(stringResource(R.string.attention)) },&#10;        text = { Text(stringResource(R.string.delete_question)) },&#10;        modifier = modifier,&#10;        dismissButton = {&#10;            TextButton(onClick = onDeleteCancel) {&#10;                Text(text = stringResource(R.string.no))&#10;            }&#10;        },&#10;        confirmButton = {&#10;            TextButton(onClick = onDeleteConfirm) {&#10;                Text(text = stringResource(R.string.yes))&#10;            }&#10;        }&#10;    )&#10;}" />
              <option name="updatedContent" value="package com.pinode.ui.home&#10;&#10;import androidx.activity.compose.BackHandler&#10;import androidx.compose.animation.core.animateFloatAsState&#10;import androidx.compose.foundation.BorderStroke&#10;import androidx.compose.foundation.background&#10;import androidx.compose.foundation.clickable&#10;import androidx.compose.foundation.interaction.MutableInteractionSource&#10;import androidx.compose.foundation.layout.Arrangement&#10;import androidx.compose.foundation.layout.Box&#10;import androidx.compose.foundation.layout.Column&#10;import androidx.compose.foundation.layout.PaddingValues&#10;import androidx.compose.foundation.layout.Row&#10;import androidx.compose.foundation.layout.Spacer&#10;import androidx.compose.foundation.layout.WindowInsets&#10;import androidx.compose.foundation.layout.asPaddingValues&#10;import androidx.compose.foundation.layout.calculateEndPadding&#10;import androidx.compose.foundation.layout.fillMaxSize&#10;import androidx.compose.foundation.layout.fillMaxWidth&#10;import androidx.compose.foundation.layout.height&#10;import androidx.compose.foundation.layout.padding&#10;import androidx.compose.foundation.layout.safeDrawing&#10;import androidx.compose.foundation.layout.size&#10;import androidx.compose.foundation.layout.wrapContentSize&#10;import androidx.compose.foundation.lazy.LazyColumn&#10;import androidx.compose.foundation.lazy.items&#10;import androidx.compose.foundation.lazy.rememberLazyListState&#10;import androidx.compose.foundation.shape.CircleShape&#10;import androidx.compose.foundation.shape.RoundedCornerShape&#10;import androidx.compose.material.icons.Icons&#10;import androidx.compose.material.icons.filled.Add&#10;import androidx.compose.material.icons.filled.ArrowUpward&#10;import androidx.compose.material.icons.filled.Bolt&#10;import androidx.compose.material.icons.filled.CalendarMonth&#10;import androidx.compose.material.icons.filled.Check&#10;import androidx.compose.material.icons.filled.Close&#10;import androidx.compose.material.icons.filled.KeyboardArrowDown&#10;import androidx.compose.material.icons.filled.Pause&#10;import androidx.compose.material.icons.outlined.ArrowUpward&#10;import androidx.compose.material.icons.outlined.Bolt&#10;import androidx.compose.material.icons.outlined.CalendarMonth&#10;import androidx.compose.material.icons.outlined.Pause&#10;import androidx.compose.material3.AlertDialog&#10;import androidx.compose.material3.ButtonGroupDefaults&#10;import androidx.compose.material3.CardDefaults&#10;import androidx.compose.material3.DropdownMenu&#10;import androidx.compose.material3.DropdownMenuItem&#10;import androidx.compose.material3.ExperimentalMaterial3Api&#10;import androidx.compose.material3.ExperimentalMaterial3ExpressiveApi&#10;import androidx.compose.material3.FloatingActionButtonMenu&#10;import androidx.compose.material3.FloatingActionButtonMenuItem&#10;import androidx.compose.material3.Icon&#10;import androidx.compose.material3.MaterialTheme&#10;import androidx.compose.material3.MaterialTheme.colorScheme&#10;import androidx.compose.material3.OutlinedCard&#10;import androidx.compose.material3.Scaffold&#10;import androidx.compose.material3.SplitButtonDefaults&#10;import androidx.compose.material3.SplitButtonLayout&#10;import androidx.compose.material3.Text&#10;import androidx.compose.material3.TextButton&#10;import androidx.compose.material3.ToggleButton&#10;import androidx.compose.material3.ToggleFloatingActionButton&#10;import androidx.compose.material3.ToggleFloatingActionButtonDefaults.animateIcon&#10;import androidx.compose.material3.TopAppBarDefaults&#10;import androidx.compose.material3.animateFloatingActionButton&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.runtime.LaunchedEffect&#10;import androidx.compose.runtime.collectAsState&#10;import androidx.compose.runtime.derivedStateOf&#10;import androidx.compose.runtime.getValue&#10;import androidx.compose.runtime.mutableIntStateOf&#10;import androidx.compose.runtime.mutableStateOf&#10;import androidx.compose.runtime.remember&#10;import androidx.compose.runtime.rememberCoroutineScope&#10;import androidx.compose.runtime.saveable.rememberSaveable&#10;import androidx.compose.runtime.setValue&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.draw.clip&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.graphics.graphicsLayer&#10;import androidx.compose.ui.graphics.vector.rememberVectorPainter&#10;import androidx.compose.ui.input.nestedscroll.nestedScroll&#10;import androidx.compose.ui.platform.LocalLayoutDirection&#10;import androidx.compose.ui.res.colorResource&#10;import androidx.compose.ui.res.dimensionResource&#10;import androidx.compose.ui.res.stringResource&#10;import androidx.compose.ui.semantics.CustomAccessibilityAction&#10;import androidx.compose.ui.semantics.Role&#10;import androidx.compose.ui.semantics.contentDescription&#10;import androidx.compose.ui.semantics.customActions&#10;import androidx.compose.ui.semantics.isTraversalGroup&#10;import androidx.compose.ui.semantics.role&#10;import androidx.compose.ui.semantics.semantics&#10;import androidx.compose.ui.semantics.stateDescription&#10;import androidx.compose.ui.semantics.traversalIndex&#10;import androidx.compose.ui.text.TextStyle&#10;import androidx.compose.ui.text.style.LineBreak&#10;import androidx.compose.ui.text.style.TextAlign&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.unit.sp&#10;import androidx.compose.ui.window.Dialog&#10;import androidx.lifecycle.viewmodel.compose.viewModel&#10;import androidx.navigation.NavController&#10;import com.pinode.BottomNavigationBar&#10;import com.pinode.PiNodeTopAppBar&#10;import com.pinode.R&#10;import com.pinode.data.Node&#10;import com.pinode.data.NodeStatus&#10;import com.pinode.ui.AppViewModelProvider&#10;import com.pinode.ui.item.DateTimeCtrl&#10;import com.pinode.ui.navigation.NavigationDestination&#10;import kotlinx.coroutines.delay&#10;import kotlinx.coroutines.launch&#10;import java.time.Duration&#10;import java.time.LocalDateTime&#10;import java.time.format.DateTimeFormatter&#10;&#10;&#10;object HomeDestination : NavigationDestination {&#10;    override val route = &quot;home&quot;&#10;    override val titleRes = R.string.today_title&#10;}&#10;&#10;@OptIn(ExperimentalMaterial3Api::class, ExperimentalMaterial3ExpressiveApi::class)&#10;@ExperimentalMaterial3Api&#10;@Composable&#10;fun HomeScreen(&#10;    navigateToNodeAddFast: () -&gt; Unit,&#10;    navigateToNodeAdd: (Boolean) -&gt; Unit,&#10;    navigateToNodeEdit: (Int) -&gt; Unit, // ← ここで編集画面への遷移関数を受け取る&#10;    navController: NavController,&#10;    viewModel: HomeViewModel = viewModel(factory = AppViewModelProvider.Factory),&#10;    modifier: Modifier = Modifier,&#10;) {&#10;    val homeUiState by viewModel.homeUiState.collectAsState()&#10;&#10;    val scrollBehavior = TopAppBarDefaults.enterAlwaysScrollBehavior()&#10;    val coroutineScope = rememberCoroutineScope()&#10;&#10;    Scaffold(&#10;        modifier = modifier.nestedScroll(scrollBehavior.nestedScrollConnection),&#10;        topBar = {&#10;            PiNodeTopAppBar(&#10;                canNavigateBack = false,&#10;                scrollBehavior = scrollBehavior&#10;            )&#10;        },&#10;        floatingActionButton = {&#10;            val listState = rememberLazyListState()&#10;            val items = listOf(&#10;                Icons.Default.Bolt to &quot;Fast Add&quot;,&#10;                Icons.Default.Add to &quot;Add&quot;&#10;            )&#10;            val fabVisible by remember { derivedStateOf { listState.firstVisibleItemIndex == 0 } }&#10;            var fabMenuExpanded by rememberSaveable { mutableStateOf(false) }&#10;            BackHandler(fabMenuExpanded) { fabMenuExpanded = false }&#10;            FloatingActionButtonMenu(&#10;                expanded = fabMenuExpanded,&#10;                button = {&#10;                    ToggleFloatingActionButton(&#10;                        modifier = Modifier&#10;                            .semantics {&#10;                                traversalIndex = -1f&#10;                                stateDescription = if (fabMenuExpanded) &quot;Expanded&quot; else &quot;Collapsed&quot;&#10;                                contentDescription = &quot;Toggle menu&quot;&#10;                            }&#10;                            .animateFloatingActionButton(&#10;                                visible = fabVisible || fabMenuExpanded,&#10;                                alignment = Alignment.BottomEnd&#10;                            ),&#10;                        checked = fabMenuExpanded,&#10;                        onCheckedChange = { fabMenuExpanded = !fabMenuExpanded }&#10;                    ) {&#10;                        val imageVector by remember {&#10;                            derivedStateOf {&#10;                                if (checkedProgress &gt; 0.5f) Icons.Filled.Close else Icons.Filled.Add&#10;                            }&#10;                        }&#10;                        Icon(&#10;                            painter = rememberVectorPainter(imageVector),&#10;                            contentDescription = null,&#10;                            modifier = Modifier.animateIcon({ checkedProgress })&#10;                        )&#10;                    }&#10;                },&#10;            ) {&#10;                items.forEachIndexed { i, item -&gt;&#10;                    FloatingActionButtonMenuItem(&#10;                        onClick = {&#10;                            if (i == 0) {&#10;                                navigateToNodeAddFast()&#10;                            } else if (i == 1) {&#10;                                navigateToNodeAdd(true)&#10;                            }&#10;                        },&#10;                        containerColor = colorScheme.primary,&#10;                        icon = { Icon(item.first, contentDescription = null) },&#10;                        text = { Text(text = item.second) },&#10;                        modifier = Modifier&#10;                            .padding(&#10;                                end = WindowInsets.safeDrawing&#10;                                    .asPaddingValues()&#10;                                    .calculateEndPadding(LocalLayoutDirection.current)&#10;                            )&#10;                            .semantics {&#10;                                isTraversalGroup = true&#10;                                if (i == items.size - 1) {&#10;                                    customActions =&#10;                                        listOf(&#10;                                            CustomAccessibilityAction(&#10;                                                label = &quot;Close menu&quot;,&#10;                                                action = {&#10;                                                    fabMenuExpanded = false&#10;                                                    true&#10;                                                }&#10;                                            )&#10;                                        )&#10;                                }&#10;                            }&#10;                        )&#10;                }&#10;            }&#10;        },&#10;        bottomBar = {&#10;            BottomNavigationBar(navController = navController)&#10;        }&#10;    ) { innerPadding -&gt;&#10;        HomeBody(&#10;            nodeList = homeUiState.nodeList.filter { !it.isCompleted &amp;&amp; it.status != NodeStatus.NOTTODO },&#10;            completeItem = { nodeId -&gt;&#10;                coroutineScope.launch {&#10;                    viewModel.updateNodeId(nodeId)&#10;                }&#10;                viewModel.completeNode(nodeId)&#10;            },&#10;            editStatus = { nodeId -&gt;&#10;                // 編集ボタン押下時にNodeEditScreenへ遷移&#10;                navigateToNodeEdit(nodeId)&#10;            },&#10;            selectedStatus = { nodeId, status -&gt;&#10;                coroutineScope.launch {&#10;                    viewModel.updateNodeId(nodeId)&#10;                }&#10;                viewModel.changeNodeStatus(nodeId, status)&#10;            },&#10;            modifier = modifier.fillMaxSize(),&#10;            contentPadding = innerPadding&#10;        )&#10;    }&#10;}&#10;&#10;@Composable&#10;fun HomeBody(&#10;    nodeList: List&lt;Node&gt;,&#10;    completeItem: (Int) -&gt; Unit,&#10;    editStatus: (Int) -&gt; Unit,&#10;    selectedStatus: (Int, NodeStatus) -&gt; Unit,&#10;    modifier: Modifier = Modifier,&#10;    contentPadding: PaddingValues = PaddingValues(0.dp)&#10;) {&#10;    Column(&#10;        horizontalAlignment = Alignment.Start,&#10;        modifier = modifier,&#10;    ) {&#10;        if (nodeList.isEmpty()) {&#10;            Text(&#10;                text = stringResource(R.string.no_node_description),&#10;                textAlign = TextAlign.Center,&#10;                style = MaterialTheme.typography.titleLarge,&#10;                modifier = Modifier.padding(contentPadding),&#10;            )&#10;        } else {&#10;            Box {&#10;                PiNodeList(&#10;                    nodeList = nodeList,&#10;                    completeItem = { node -&gt; completeItem(node.id)},&#10;                    editStatus = { node -&gt; editStatus(node.id) },&#10;                    selectedStatus = { node, status -&gt; selectedStatus(node.id, status)},&#10;                    contentPadding = contentPadding,&#10;                    modifier = Modifier.padding(horizontal = dimensionResource(id = R.dimen.padding_small))&#10;                )&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;&#10;@Composable&#10;private fun PiNodeList(&#10;    nodeList: List&lt;Node&gt;,&#10;    completeItem: (Node) -&gt; Unit,&#10;    editStatus: (Node) -&gt; Unit,&#10;    selectedStatus: (Node, NodeStatus) -&gt; Unit,&#10;    contentPadding: PaddingValues,&#10;    modifier: Modifier = Modifier&#10;) {&#10;    Box {&#10;        var showDialog by remember { mutableStateOf(false) }&#10;        var selectedNode by remember { mutableStateOf&lt;Node?&gt;(null) }&#10;&#10;        LazyColumn(&#10;            modifier = modifier,&#10;            contentPadding = contentPadding&#10;        ) {&#10;            if (nodeList.isNotEmpty()) {&#10;                items(&#10;                    items = nodeList,&#10;                    key = { node -&gt; node.id }  // keyを明示的に設定&#10;                ) { item -&gt;&#10;                    PiNodeItem(&#10;                        item = item,&#10;                        onItemTap = { node -&gt;&#10;                            selectedNode = node&#10;                            showDialog = true&#10;                        },&#10;                        completeItem = { node -&gt; completeItem(node)},&#10;                        editStatus = { node -&gt; editStatus(node) },&#10;                        showDialog = showDialog&#10;                    )&#10;                }&#10;            }&#10;        }&#10;&#10;        // null safety&#10;        if (showDialog &amp;&amp; selectedNode != null) {&#10;            NodeDetailDialog(&#10;                onDismissRequest = {&#10;                    showDialog = false&#10;                    selectedNode = null&#10;                },&#10;                item = selectedNode!!, // null safety&#10;                selectedStatus = { node, status -&gt; selectedStatus(node, status) },&#10;                editStatus = {&#10;                    node -&gt; editStatus(node)&#10;                    showDialog = false&#10;                }&#10;            )&#10;        }&#10;    }&#10;}&#10;&#10;&#10;@Composable&#10;fun PiNodeItem(&#10;    item: Node,&#10;    onItemTap: (Node) -&gt; Unit,&#10;    completeItem: (Node) -&gt; Unit,&#10;    editStatus: (Node) -&gt; Unit,&#10;    showDialog: Boolean,&#10;    modifier: Modifier = Modifier&#10;) {&#10;    // 状態を使用して現在時刻を保持し、更新可能にする&#10;    var currentTime by remember { mutableStateOf(DateTimeCtrl().getNow()) }&#10;&#10;    // 一定間隔で時間を更新&#10;    LaunchedEffect(key1 = Unit) {&#10;        while(true) {&#10;            delay(100)&#10;            currentTime = DateTimeCtrl().getNow()&#10;        }&#10;    }&#10;&#10;    val deadline = item.deadline&#10;    val duration = deadline?.let { dateTime -&gt;&#10;        try {&#10;            Duration.between(LocalDateTime.now(), dateTime)&#10;        } catch (e: Exception) {&#10;            Duration.ZERO&#10;        }&#10;    } ?: Duration.ZERO&#10;&#10;    val remainingTime = if (deadline == null) {&#10;        &quot;&quot; // 期限なし&#10;    } else if (deadline &gt; LocalDateTime.now() &amp;&amp; duration &lt;= Duration.ofHours(1)){&#10;        // last 1 hour&#10;        duration.toMinutes()&#10;    } else if (duration == Duration.ZERO) {&#10;        // out of deadline&#10;        &quot;0&quot;&#10;    } else if (deadline &lt; LocalDateTime.now()) {&#10;        // out of deadline&#10;        val formatter = DateTimeFormatter.ofPattern(&quot;yyyy M/d H:mm&quot;)&#10;        &quot;-${formatter.format(item.deadline)}-&quot;&#10;    } else if (deadline.year &gt; LocalDateTime.now().year) {&#10;        // others year&#10;        val formatter = DateTimeFormatter.ofPattern(&quot;yyyy M/d H:mm&quot;)&#10;        formatter.format(item.deadline)&#10;    } else if (deadline.month == LocalDateTime.now().month &amp;&amp; deadline.dayOfMonth == LocalDateTime.now().dayOfMonth) {&#10;        // today&#10;        val formatter = DateTimeFormatter.ofPattern(&quot;H:mm&quot;)&#10;        formatter.format(item.deadline)&#10;    } else {&#10;        // this year&#10;        val formatter = DateTimeFormatter.ofPattern(&quot;M/d H:mm&quot;)&#10;        formatter.format(item.deadline)&#10;    }&#10;&#10;    OutlinedCard(&#10;        colors = CardDefaults.cardColors(&#10;            containerColor = colorScheme.surface,&#10;        ),&#10;        border = BorderStroke(1.dp, Color.White),&#10;        modifier = Modifier&#10;            .padding(bottom = 6.dp)&#10;            .fillMaxWidth()&#10;            .clickable(&#10;                indication = null,&#10;                interactionSource = remember { MutableInteractionSource() }&#10;            ) {&#10;                onItemTap(item)&#10;            }&#10;    ) {&#10;        Column(modifier = Modifier&#10;            .fillMaxWidth()&#10;            .padding(6.dp)&#10;        ) {&#10;            // ここでRowを使って左右に分ける&#10;            Row(&#10;                verticalAlignment = Alignment.CenterVertically,&#10;                horizontalArrangement = Arrangement.SpaceBetween,&#10;                modifier = Modifier.fillMaxWidth()&#10;            ) {&#10;                // ステータスインジケーター&#10;                Box(&#10;                    modifier = Modifier&#10;                        .padding(start = 6.dp, top = 6.dp)&#10;                        .size(20.dp)&#10;                        .clip(CircleShape)&#10;                        .background(&#10;                            if (item.status != null) {&#10;                                colorResource(item.status.color)&#10;                            } else {&#10;                                Color.Black&#10;                            }&#10;                        )&#10;                )&#10;                // SplitButton&#10;                Box(&#10;                    modifier = Modifier&#10;                        .wrapContentSize()&#10;                        .height(40.dp)&#10;                ) {&#10;                    if(!showDialog) {&#10;                        SplitButton(item = item, completeItem = completeItem, editStatus = editStatus) }&#10;                }&#10;            }&#10;            Text( // deadline&#10;                text = remainingTime.toString(),&#10;                color = Color.Gray,&#10;                fontSize = 16.sp,&#10;            )&#10;&#10;            Text( // title&#10;                text = item.title,&#10;                color = Color.White,&#10;                fontSize = 32.sp,&#10;                modifier = Modifier.padding(start = 8.dp),&#10;                style = TextStyle.Default.copy(&#10;                    lineBreak = LineBreak.Heading&#10;                )&#10;            )&#10;                // TODO Sub Todo List&#10;        }&#10;    }&#10;}&#10;&#10;@OptIn(ExperimentalMaterial3ExpressiveApi::class)&#10;@Composable&#10;private fun SplitButton(&#10;    item: Node, completeItem: (Node) -&gt; Unit, editStatus: (Node) -&gt; Unit&#10;) {&#10;    var checked by remember { mutableStateOf(false) }&#10;    SplitButtonLayout(&#10;        modifier = Modifier.height(40.dp),&#10;        leadingButton = {&#10;            SplitButtonDefaults.LeadingButton(&#10;                onClick = {&#10;                    // 同期的に状態を更新&#10;                    completeItem(item)&#10;                },&#10;                modifier = Modifier.height(40.dp)&#10;            ) {&#10;                Icon(&#10;                    Icons.Filled.Check,&#10;                    modifier = Modifier.size(16.dp),&#10;                    contentDescription = &quot;Localized description&quot;,&#10;                )&#10;                Spacer(Modifier.size(4.dp))&#10;                Text(&quot;Complete&quot;, fontSize = 12.sp)&#10;            }&#10;        },&#10;        trailingButton = {&#10;            SplitButtonDefaults.TrailingButton(&#10;                checked = checked,&#10;                onCheckedChange = {&#10;                    checked = it&#10;                },&#10;                modifier = Modifier&#10;                    .height(40.dp)&#10;                    .semantics {&#10;                        stateDescription =&#10;                            if (checked) &quot;Expanded&quot; else &quot;Collapsed&quot;&#10;                        contentDescription = &quot;Toggle Button&quot;&#10;                    },&#10;            ) {&#10;                val rotation: Float by animateFloatAsState(&#10;                    targetValue = if (checked) 180f else 0f,&#10;                    label = &quot;Trailing Icon Rotation&quot;,&#10;                )&#10;                Icon(&#10;                    Icons.Filled.KeyboardArrowDown,&#10;                    modifier = Modifier&#10;                        .size(16.dp)&#10;                        .graphicsLayer {&#10;                            this.rotationZ = rotation&#10;                        },&#10;                    contentDescription = &quot;Localized description&quot;,&#10;                )&#10;            }&#10;        },&#10;    )&#10;    DropdownMenu(&#10;        expanded = checked,&#10;        onDismissRequest = { checked = false },&#10;        modifier = Modifier.clip(RoundedCornerShape(6.dp))&#10;    ) {&#10;        DropdownMenuItem(&#10;            text = { Text(&quot;Edit&quot;)},&#10;            onClick = {&#10;                editStatus(item)&#10;                checked = false // メニューを閉じる&#10;            },&#10;        )&#10;    }&#10;}&#10;&#10;@OptIn(ExperimentalMaterial3ExpressiveApi::class)&#10;@Composable&#10;private fun NodeDetailDialog(&#10;    onDismissRequest: () -&gt; Unit,&#10;    item : Node,&#10;    selectedStatus: (Node, NodeStatus) -&gt; Unit,&#10;    editStatus: (Node) -&gt; Unit,&#10;) {&#10;    Dialog(&#10;        onDismissRequest = onDismissRequest,&#10;    ) {&#10;        Column {&#10;            PiNodeItem(&#10;                item = item,&#10;                onItemTap = { node -&gt; editStatus(node) },&#10;                completeItem = {},&#10;                editStatus = {},&#10;                showDialog = true,&#10;            )&#10;            Spacer(modifier = Modifier.height(8.dp))&#10;            DetailsButtonGroup(item, selectedStatus)&#10;        }&#10;    }&#10;}&#10;&#10;&#10;@Composable&#10;@ExperimentalMaterial3ExpressiveApi&#10;private fun DetailsButtonGroup(item: Node, selectedStatus: (Node, NodeStatus) -&gt; Unit) {&#10;    val options = listOf(&#10;        NodeStatus.WORKING, NodeStatus.PAUSE, NodeStatus.CARRYOVER, NodeStatus.FAST&#10;    )&#10;    val unCheckedIcons =&#10;        listOf(Icons.Outlined.ArrowUpward, Icons.Outlined.Pause, Icons.Outlined.CalendarMonth, Icons.Outlined.Bolt)&#10;    val checkedIcons =&#10;        listOf(Icons.Default.ArrowUpward, Icons.Default.Pause, Icons.Default.CalendarMonth, Icons.Default.Bolt)&#10;    var selectedIndex by remember { mutableIntStateOf(0) }&#10;&#10;    Row(&#10;        Modifier.padding(horizontal = 8.dp),&#10;        horizontalArrangement = Arrangement.spacedBy(ButtonGroupDefaults.ConnectedSpaceBetween),&#10;    ) {&#10;        options.forEachIndexed { index, label -&gt;&#10;            ToggleButton(&#10;                checked = selectedIndex == index,&#10;                onCheckedChange = {&#10;                    selectedIndex = index&#10;                    selectedStatus(item, options[index])&#10;                    },&#10;                modifier = Modifier&#10;                    .weight(1f)&#10;                    .semantics { role = Role.RadioButton },&#10;                shapes =&#10;                when (index) {&#10;                    0 -&gt; ButtonGroupDefaults.connectedLeadingButtonShapes()&#10;                    options.lastIndex -&gt; ButtonGroupDefaults.connectedTrailingButtonShapes()&#10;                    else -&gt; ButtonGroupDefaults.connectedMiddleButtonShapes()&#10;                },&#10;            ) {&#10;                Icon(&#10;                    if (selectedIndex == index) checkedIcons[index] else unCheckedIcons[index],&#10;                    contentDescription = &quot;Localized description&quot;,&#10;                )&#10;            }&#10;        }&#10;    }&#10;} // TODO add edit and delete button&#10;&#10;@Composable&#10;private fun DeleteConfirmationDialog(&#10;    onDeleteConfirm: () -&gt; Unit, onDeleteCancel: () -&gt; Unit, modifier: Modifier = Modifier&#10;) {&#10;    AlertDialog(onDismissRequest = { /* Do nothing */ },&#10;        title = { Text(stringResource(R.string.attention)) },&#10;        text = { Text(stringResource(R.string.delete_question)) },&#10;        modifier = modifier,&#10;        dismissButton = {&#10;            TextButton(onClick = onDeleteCancel) {&#10;                Text(text = stringResource(R.string.no))&#10;            }&#10;        },&#10;        confirmButton = {&#10;            TextButton(onClick = onDeleteConfirm) {&#10;                Text(text = stringResource(R.string.yes))&#10;            }&#10;        }&#10;    )&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/pinode/ui/item/NodeEditScreen.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/pinode/ui/item/NodeEditScreen.kt" />
              <option name="originalContent" value="package com.pinode.ui.item&#10;&#10;import androidx.compose.foundation.BorderStroke&#10;import androidx.compose.foundation.layout.fillMaxWidth&#10;import androidx.compose.foundation.layout.padding&#10;import androidx.compose.foundation.rememberScrollState&#10;import androidx.compose.foundation.verticalScroll&#10;import androidx.compose.material3.Button&#10;import androidx.compose.material3.CardDefaults&#10;import androidx.compose.material3.MaterialTheme&#10;import androidx.compose.material3.MaterialTheme.colorScheme&#10;import androidx.compose.material3.OutlinedCard&#10;import androidx.compose.material3.OutlinedTextField&#10;import androidx.compose.material3.OutlinedTextFieldDefaults&#10;import androidx.compose.material3.Text&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.runtime.getValue&#10;import androidx.compose.runtime.mutableStateOf&#10;import androidx.compose.runtime.remember&#10;import androidx.compose.runtime.rememberCoroutineScope&#10;import androidx.compose.runtime.setValue&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.res.stringResource&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.window.Dialog&#10;import androidx.lifecycle.viewmodel.compose.viewModel&#10;import com.pinode.R&#10;import com.pinode.ui.AppViewModelProvider&#10;import com.pinode.ui.navigation.NavigationDestination&#10;import kotlinx.coroutines.launch&#10;&#10;&#10;object NodeEditDestination : NavigationDestination {&#10;    override val route = &quot;node_edit&quot;&#10;    override val titleRes = R.string.edit_node_title&#10;    const val nodeIdArg = &quot;nodeId&quot;&#10;    val routeWithArgs = &quot;$route/{$nodeIdArg}&quot;&#10;}&#10;&#10;@Composable&#10;fun NodeEditScreen(&#10;    navigateBack: () -&gt; Unit,&#10;    onNavigateUp: () -&gt; Unit,&#10;    modifier: Modifier = Modifier,&#10;    viewModel: NodeEditViewModel = viewModel(factory = AppViewModelProvider.Factory)&#10;) {&#10;    val nodeUiState = viewModel.nodeUiState&#10;    val coroutineScope = rememberCoroutineScope()&#10;    NodeEditDialog(&#10;        onDismissRequest = onNavigateUp,&#10;        nodeUiState = nodeUiState,&#10;        onValueChange = viewModel::updateUiState,&#10;        onSaveClick = {&#10;            coroutineScope.launch {&#10;                viewModel.updateNode()&#10;                navigateBack()&#10;            }&#10;        },&#10;        modifier = Modifier.verticalScroll(rememberScrollState())&#10;    )&#10;    Button(&#10;        onClick = {&#10;            coroutineScope.launch {&#10;                viewModel.updateNode()&#10;                navigateBack()&#10;            }&#10;        },&#10;        enabled = nodeUiState.isEntryValid,&#10;        shape = MaterialTheme.shapes.small,&#10;        modifier = Modifier.fillMaxWidth()&#10;    ) {&#10;        Text(text = stringResource(R.string.save_action))&#10;    }&#10;}&#10;&#10;&#10;" />
              <option name="updatedContent" value="package com.pinode.ui.item&#10;&#10;import androidx.compose.foundation.BorderStroke&#10;import androidx.compose.foundation.layout.fillMaxWidth&#10;import androidx.compose.foundation.layout.padding&#10;import androidx.compose.foundation.rememberScrollState&#10;import androidx.compose.foundation.verticalScroll&#10;import androidx.compose.material3.Button&#10;import androidx.compose.material3.CardDefaults&#10;import androidx.compose.material3.MaterialTheme&#10;import androidx.compose.material3.MaterialTheme.colorScheme&#10;import androidx.compose.material3.OutlinedCard&#10;import androidx.compose.material3.OutlinedTextField&#10;import androidx.compose.material3.OutlinedTextFieldDefaults&#10;import androidx.compose.material3.Text&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.runtime.getValue&#10;import androidx.compose.runtime.mutableStateOf&#10;import androidx.compose.runtime.remember&#10;import androidx.compose.runtime.rememberCoroutineScope&#10;import androidx.compose.runtime.setValue&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.res.stringResource&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.window.Dialog&#10;import androidx.lifecycle.viewmodel.compose.viewModel&#10;import com.pinode.R&#10;import com.pinode.ui.AppViewModelProvider&#10;import com.pinode.ui.navigation.NavigationDestination&#10;import kotlinx.coroutines.launch&#10;&#10;&#10;object NodeEditDestination : NavigationDestination {&#10;    override val route = &quot;node_edit&quot;&#10;    override val titleRes = R.string.edit_node_title&#10;    const val nodeIdArg = &quot;nodeId&quot;&#10;    val routeWithArgs = &quot;$route/{$nodeIdArg}&quot;&#10;}&#10;&#10;@Composable&#10;fun NodeEditScreen(&#10;    navigateBack: () -&gt; Unit,&#10;    onNavigateUp: () -&gt; Unit,&#10;    modifier: Modifier = Modifier,&#10;    viewModel: NodeEditViewModel = viewModel(factory = AppViewModelProvider.Factory)&#10;) {&#10;    val nodeUiState = viewModel.nodeUiState&#10;    val coroutineScope = rememberCoroutineScope()&#10;&#10;    // NodeAddScreenのUIを流用して編集画面を構成&#10;    NodeAddScreen(&#10;        nodeUiState = nodeUiState,&#10;        onValueChange = viewModel::updateUiState,&#10;        onSaveClick = {&#10;            coroutineScope.launch {&#10;                viewModel.updateNode()&#10;                navigateBack()&#10;            }&#10;        },&#10;        onNavigateUp = onNavigateUp,&#10;        isEdit = true, // 編集モードであることを明示&#10;        modifier = modifier&#10;    )&#10;}&#10;&#10;// NodeAddScreenのComposableを編集用にも使えるように引数追加&#10;@Composable&#10;fun NodeAddScreen(&#10;    nodeUiState: NodeUiState,&#10;    onValueChange: (NodeDetails) -&gt; Unit,&#10;    onSaveClick: () -&gt; Unit,&#10;    onNavigateUp: () -&gt; Unit,&#10;    isEdit: Boolean = false,&#10;    modifier: Modifier = Modifier&#10;) {&#10;    Dialog(onDismissRequest = onNavigateUp) {&#10;        OutlinedCard(&#10;            border = BorderStroke(1.dp, Color.White),&#10;            colors = CardDefaults.cardColors(containerColor = colorScheme.surface),&#10;            modifier = modifier&#10;        ) {&#10;            Column(&#10;                modifier = Modifier&#10;                    .padding(16.dp)&#10;                    .verticalScroll(rememberScrollState())&#10;            ) {&#10;                Text(&#10;                    text = if (isEdit) stringResource(R.string.edit_node_title) else stringResource(R.string.add_node_title),&#10;                    style = MaterialTheme.typography.titleLarge,&#10;                    modifier = Modifier.padding(bottom = 8.dp)&#10;                )&#10;                OutlinedTextField(&#10;                    value = nodeUiState.nodeDetails.title,&#10;                    onValueChange = { onValueChange(nodeUiState.nodeDetails.copy(title = it)) },&#10;                    label = { Text(stringResource(R.string.title)) },&#10;                    modifier = Modifier.fillMaxWidth(),&#10;                    colors = OutlinedTextFieldDefaults.colors(&#10;                        focusedBorderColor = colorScheme.primary,&#10;                        unfocusedBorderColor = Color.Gray&#10;                    )&#10;                )&#10;                OutlinedTextField(&#10;                    value = nodeUiState.nodeDetails.description,&#10;                    onValueChange = { onValueChange(nodeUiState.nodeDetails.copy(description = it)) },&#10;                    label = { Text(stringResource(R.string.description)) },&#10;                    modifier = Modifier&#10;                        .fillMaxWidth()&#10;                        .padding(top = 8.dp),&#10;                    colors = OutlinedTextFieldDefaults.colors(&#10;                        focusedBorderColor = colorScheme.primary,&#10;                        unfocusedBorderColor = Color.Gray&#10;                    )&#10;                )&#10;                // ...必要に応じて他のフィールドも追加...&#10;                Button(&#10;                    onClick = onSaveClick,&#10;                    enabled = nodeUiState.isEntryValid,&#10;                    shape = MaterialTheme.shapes.small,&#10;                    modifier = Modifier&#10;                        .fillMaxWidth()&#10;                        .padding(top = 16.dp)&#10;                ) {&#10;                    Text(text = stringResource(R.string.save_action))&#10;                }&#10;            }&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>